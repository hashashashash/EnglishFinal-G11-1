<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ones Who Walk Away from Omelas</title>
    <style>
        body {
            font-family: 'Helvetica Neue', sans-serif;
            margin: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
            overflow-x: hidden;
            opacity: 0;
            transition: opacity 0.5s;
            scroll-snap-type: y mandatory;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .fade-out {
            opacity: 0 !important;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        .content {
            position: relative;
            z-index: 1;
            flex: 1;
        }

        h1,
        h2 {
            font-weight: 300;
            text-align: center;
            color: #fff;
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 2em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-top: 0;
        }

        p {
            font-size: 1.1em;
            line-height: 1.6;
            text-align: justify;
        }

                header,
        .section {
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            scroll-snap-align: start;
        }

        .section {
            opacity: 0;
            transform: translateY(50px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-inner {
            background-color: rgba(26, 26, 26, 0.7);
            padding: 40px;
            border-radius: 8px;
            max-width: 800px;
        }

        header .section-inner {
            background-color: transparent;
            text-align: center;
        }

        .cta-button {
            display: inline-block;
            padding: 12px 24px;
            border: 1px solid #99ccff;
            border-radius: 4px;
            color: #99ccff;
            text-decoration: none;
            font-weight: bold;
            margin-top: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        .cta-button:hover {
            background-color: #99ccff;
            color: #1a1a1a;
        }

        .intro-paragraph {
            font-size: 1.1em;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
            color: #cccccc;
            max-width: 700px;
            margin: 0 auto;
            /* Removed top margin */
        }

        .intro-text-wrapper {
            background-color: rgba(26, 26, 26, 0.7);
            padding: 30px;
            border-radius: 8px;
            margin-top: 30px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .core-question {
            font-size: 1.15em;
            line-height: 1.6;
            text-align: center;
            font-weight: bold;
            color: #99ccff;
            max-width: 700px;
            margin: 25px auto 0 auto;
        }

                        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px;
            margin-top: 20px;
        }

        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(26, 26, 26, 0.8);
            padding: 15px 0;
            text-align: center;
            z-index: 10;
        }

        .nav-bar a {
            color: #e0e0e0;
            text-decoration: none;
            margin: 0 20px;
            font-size: 1.1em;
            transition: color 0.3s;
        }

        .nav-bar a:hover {
            color: #99ccff;
        }
    </style>
</head>

<body>
    <div class="nav-bar">
        <a href="#plot">The Plot</a>
        <a href="#themes">The Themes</a>
        <a href="#messages">The Messages</a>
        <a href="#guernica">The Painting</a>
    </div>
    <div id="scene-container"></div>
    <div class="content">
        <header>
            <div class="section-inner">
                <h1>The Ones Who Walk Away from Omelas</h1>
                <div class="intro-text-wrapper">
                    <p class="intro-paragraph">
                        Step into the intersection of literature and art, where Ursula K. Le Guin’s haunting 1973 short
                        story The Ones Who Walk Away from Omelas meets Pablo Picasso’s iconic 1937 painting Guernica.
                        Both works confront humanity with a searing truth: joy, peace, and progress often come at the
                        cost of unspeakable suffering. This website explores how two creative giants—separated by
                        medium, culture, and context—illuminate the same dark underbelly of civilization: the sacrifice
                        of the vulnerable for the comfort of the many.
                    </p>
                    <p class="core-question">
                        <strong>Core Question:</strong> What happens when a society’s happiness is built on the misery
                        of one? How do we respond to injustice that feels “unavoidable”? Le Guin and Picasso force us to
                        confront these questions, challenging us to reject complacency and confront the hidden violence
                        of “utopia.”
                    </p>
                </div>
                <a href="story/index.html" class="cta-button">Experience the Interactive Story</a>
                <a href="story/text.html" class="cta-button">Read the Original Text</a>
            </div>
        </header>
        <section class="section" id="plot">
            <div class="section-inner">
                <h2>The Plot</h2>
                <p>The town of Omelas is a place of unending joy. It has summer festivities, laughter, song, and plenty.
                    The streets are filled with children dancing, the riders warming up for a race, and even the very
                    air is thick with joy. But this place of joy holds a ghastly secret. Down below this utopian town
                    lies a dirty basement where a child is kept. The child is feeble-minded, starving, and covered with
                    sores. This child is being neglected and abused. Yet every person living in Omelas understands that
                    this child is being held down there. Moreover, their own joy is made possible by the misery of this
                    child. Should the child suddenly be set free, the town will fall apart. Many people are willing to
                    live under this cruel condition. However, there are some who choose to walk out on it and leave the
                    town with unknown consequences.</p>
                <a href="story/text.html" class="cta-button">Read Full Text & Analysis</a>
            </div>
        </section>
        <section class="section" id="themes">
            <div class="section-inner">
                <h2>The Themes</h2>
                <p>The story explores several profound philosophical themes, most notably the conflict between
                    utilitarianism and individual rights. It questions whether the happiness of the many can justify the
                    suffering of the few, forcing the reader to confront uncomfortable questions about morality,
                    justice, and the nature of happiness itself.</p>
                <p>Another central theme is the idea of a scapegoat, a single individual who is made to bear the sins
                    and suffering of the entire community. The child in the story serves as a symbol of the oppressed
                    and marginalized, those who are sacrificed for the sake of the greater good.</p>
                <a href="story/themes.html" class="cta-button">Read Full Theme Analysis</a>
            </div>
        </section>
        <section class="section" id="messages">
            <div class="section-inner">
                <h2>The Messages</h2>
                <p>The story's most powerful message is delivered through the actions of those who choose to walk away
                    from Omelas. Unable to reconcile themselves with the injustice that underpins their society, they
                    silently leave the city, venturing into an unknown and uncertain future. Their departure is a
                    powerful act of defiance, a rejection of a flawed utopia and a testament to the human capacity for
                    empathy and moral courage.</p>
                <p>Ultimately, "The Ones Who Walk Away from Omelas" is a story that challenges our own moral certainties
                    and forces us to consider the hidden costs of our own happiness. It reminds us that true utopia
                    cannot be built on a foundation of suffering and that sometimes, the most ethical choice is to walk
                    away from a system that is fundamentally unjust.</p>
            </div>
        </section>
        <section class="section" id="guernica">
            <div class="section-inner">
                <h2>The Painting: Guernica (1937)</h2>
                <p>Pablo Picasso's monumental anti-war mural, *Guernica*, serves as a powerful visual counterpart to
                    Omelas. Painted in response to the bombing of a Basque village during the Spanish Civil War, it
                    depicts the raw, fragmented agony of innocent victims. While Omelas hides its suffering in a dark
                    cellar, Guernica screams it aloud in stark monochrome, forcing the viewer to confront the brutal
                    reality of violence. Both works, however, explore the same theme: the suffering of the few for the
                    supposed benefit of the many.</p>
                <a href="painting/index.html" class="cta-button">Explore the Connection</a>
            </div>
        </section>
    </div>
            <footer>
        A web experience based on the short story by Ursula K. Le Guin. Pablo Picasso’s Guernica (1937)
    </footer>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, world, cars = [], streets = [], intersectionMap;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('scene-container').appendChild(renderer.domElement);

            world = new THREE.Group();
            scene.add(world);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            world.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5);
            world.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9, metalness: 0.1, transparent: true });

            // Create a blurred edge for the ground
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 256);
            const groundTexture = new THREE.CanvasTexture(canvas);
            groundMaterial.alphaMap = groundTexture;

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            world.add(ground);

            // Streets
            const streetGroup = new THREE.Group();
            const streetParticleMaterial = new THREE.PointsMaterial({ size: 0.03, color: 0x444444 });

            const generateStreets = () => {
                const streetPoints = [];
                intersectionMap = new Map();
                const coordToString = (v) => `${v.x.toFixed(1)},${v.z.toFixed(1)}`;

                const addStreet = (start, end) => {
                    const street = { start, end, id: streets.length, length: start.distanceTo(end) };
                    streets.push(street);

                    const startStr = coordToString(start);
                    const endStr = coordToString(end);

                    if (!intersectionMap.has(startStr)) intersectionMap.set(startStr, []);
                    if (!intersectionMap.has(endStr)) intersectionMap.set(endStr, []);

                    intersectionMap.get(startStr).push(street);
                    intersectionMap.get(endStr).push(street);

                    const pointsCount = Math.floor(street.length / 0.2);
                    for (let i = 0; i < pointsCount; i++) {
                        streetPoints.push(new THREE.Vector3().lerpVectors(start, end, i / pointsCount));
                    }
                };

                const generateSegment = (start, angle, length, depth) => {
                    if (depth > 8 || length < 1) return;

                    const end = new THREE.Vector3(
                        start.x + Math.cos(angle) * length,
                        start.y,
                        start.z + Math.sin(angle) * length
                    );

                    if (Math.abs(end.x) > 49 || Math.abs(end.z) > 49) return;

                    addStreet(start, end);

                    const dist = start.length();
                    const isDowntown = dist < 15;

                    const branchProb = isDowntown ? 0.9 : 0.3;
                    const turnAngle = (Math.random() * 0.6 + 0.7) * Math.PI / 2; // sharper turns downtown
                    const lengthMultiplier = isDowntown ? (Math.random() * 0.2 + 0.4) : (Math.random() * 0.2 + 0.8);

                    if (Math.random() < branchProb) {
                        generateSegment(end, angle + turnAngle, length * lengthMultiplier, depth + 1);
                    }
                    if (Math.random() < branchProb) {
                        generateSegment(end, angle - turnAngle, length * lengthMultiplier, depth + 1);
                    }
                };
                for (let i = 0; i < 16; i++) {
                    generateSegment(new THREE.Vector3(0, 0.01, 0), Math.random() * Math.PI * 2, 20, 0);
                }
                // Add sparse roads on the outskirts
                for (let i = 0; i < 4; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 30 + Math.random() * 15; // Start roads far from the center
                    const startPoint = new THREE.Vector3(Math.cos(angle) * radius, 0.01, Math.sin(angle) * radius);
                    generateSegment(startPoint, Math.random() * Math.PI * 2, 10, 4); // Start with a higher depth to limit branching
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(streetPoints);
                streetGroup.add(new THREE.Points(geometry, streetParticleMaterial));
            };

            generateStreets();
            world.add(streetGroup);

            // City Particles
            const cityParticles = new THREE.Group();
            const particleMaterial = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });

            const createBuilding = (width, height, depth, particleCount) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const color = new THREE.Color();

                for (let i = 0; i < positions.length; i += 3) {
                    const side = Math.floor(Math.random() * 6);
                    let x, y, z;

                    if (side === 0 || side === 1) { x = (side === 0 ? -width : width) / 2; y = (Math.random() - 0.5) * height; z = (Math.random() - 0.5) * depth; }
                    else if (side === 2 || side === 3) { x = (Math.random() - 0.5) * width; y = (side === 2 ? -height : height) / 2; z = (Math.random() - 0.5) * depth; }
                    else { x = (Math.random() - 0.5) * width; y = (Math.random() - 0.5) * height; z = (side === 4 ? -depth : depth) / 2; }

                    positions[i] = x; positions[i + 1] = y; positions[i + 2] = z;

                    if (Math.random() > 0.95) color.set(0x99ccff);
                    else { const intensity = Math.random() * 0.3 + 0.3; color.setRGB(intensity, intensity, intensity); }

                    colors[i] = color.r; colors[i + 1] = color.g; colors[i + 2] = color.b;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                return new THREE.Points(geometry, particleMaterial);
            };

            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.pow(Math.random(), 0.9) * 43; // Start building further from the center
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const dist = Math.sqrt(x * x + z * z);
                const downtownFactor = Math.pow(1 - Math.min(dist / 48, 1), 1.5);

                // Smoothly interpolate building height
                const h_min = 1 + 9 * downtownFactor;
                const h_max = 5 + 20 * downtownFactor;
                const height = h_min + Math.random() * (h_max - h_min);

                // Smoothly interpolate building width and depth
                const w_min = 0.5 + 0.5 * downtownFactor;
                const w_max = 2 + 1.5 * downtownFactor;
                const width = w_min + Math.random() * (w_max - w_min);
                const depth = w_min + Math.random() * (w_max - w_min);

                // Smoothly interpolate particle density
                const particleDensity = 40 + 20 * downtownFactor;
                const particleCount = Math.floor(width * height * depth * particleDensity);

                if (particleCount > 0) {
                    const building = createBuilding(width, height, depth, particleCount);
                    building.position.set(x, height / 2, z);
                    cityParticles.add(building);
                }
            }
            world.add(cityParticles);

            // Trees
            const treeParticles = new THREE.Group();
            const treeParticleMaterial = new THREE.PointsMaterial({ size: 0.1, color: 0x4caf50 });

            for (let i = 0; i < 200; i++) {
                const treeGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(30 * 3);
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] = (Math.random() - 0.5) * 0.5;
                    positions[j + 1] = Math.random() * 1;
                    positions[j + 2] = (Math.random() - 0.5) * 0.5;
                }
                treeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const tree = new THREE.Points(treeGeometry, treeParticleMaterial);

                const x = (Math.random() - 0.5) * 90;
                const z = (Math.random() - 0.5) * 90;

                tree.position.set(x, 0, z);
                treeParticles.add(tree);
            }
            world.add(treeParticles);

            // Cars
            const createCar = () => {
                if (streets.length === 0) return;
                const carGeometry = new THREE.BufferGeometry();
                carGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
                const carMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xffffff });
                const car = new THREE.Points(carGeometry, carMaterial);

                const street = streets[Math.floor(Math.random() * streets.length)];
                const speed = Math.random() * 0.05 + 0.05;

                const fromStart = Math.random() > 0.5;
                const startNode = fromStart ? street.start : street.end;
                const endNode = fromStart ? street.end : street.start;

                car.position.copy(startNode);
                world.add(car);
                cars.push({ mesh: car, speed, street, progress: 0, startNode, endNode });
            };
            for (let i = 0; i < 150; i++) {
                createCar();
            }

            camera.position.set(0, 35, 45);
            camera.lookAt(0, 0, 0);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.maxPolarAngle = Math.PI / 2;

            window.addEventListener('scroll', onScroll, false);
            window.addEventListener('wheel', onWheel, { passive: true });
            window.addEventListener('resize', onWindowResize, false);

            animate();
            revealSections();
        }

        function onScroll() {
            const scrollMax = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = window.scrollY / scrollMax;
            const startY = 35;
            const endY = 5;
            camera.position.y = startY - scrollPercent * (startY - endY);
            camera.lookAt(0, 0, 0);
        }

        function onWheel(event) {
            world.rotation.y += event.deltaX * 0.001;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            world.rotation.y += 0.0002;

            const coordToString = (v) => `${v.x.toFixed(1)},${v.z.toFixed(1)}`;

            cars.forEach(car => {
                car.progress += car.speed / car.street.length;

                if (car.progress >= 1) {
                    const currentEndStr = coordToString(car.endNode);
                    const possibleNextStreets = (intersectionMap.get(currentEndStr) || []).filter(s => s.id !== car.street.id);

                    let nextStreet;
                    if (possibleNextStreets.length > 0) {
                        nextStreet = possibleNextStreets[Math.floor(Math.random() * possibleNextStreets.length)];
                    } else {
                        nextStreet = car.street; // Turn around if it's a dead end
                    }

                    car.street = nextStreet;
                    car.progress = 0;

                    if (car.endNode.distanceTo(nextStreet.start) < 0.1) {
                        car.startNode = nextStreet.start;
                        car.endNode = nextStreet.end;
                    } else {
                        car.startNode = nextStreet.end;
                        car.endNode = nextStreet.start;
                    }
                }

                if (car.street) {
                    car.mesh.position.lerpVectors(car.startNode, car.endNode, car.progress);
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        function revealSections() {
            const sections = document.querySelectorAll('.section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 });

            sections.forEach(section => {
                observer.observe(section);
            });
        }

        init();

        document.addEventListener("DOMContentLoaded", function (event) {
            document.body.style.opacity = 1;
            document.querySelector('.cta-button').addEventListener('click', (e) => {
                e.preventDefault();
                navigateToStory();
            });
        });

        function navigateToStory() {
            document.body.classList.add('fade-out');
            setTimeout(() => {
                window.location.href = 'story/index.html';
            }, 500);
        }
    </script>
</body>

</html>